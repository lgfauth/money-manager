@using System.Globalization
@using System.Linq
@using Microsoft.AspNetCore.Components
@using System.Threading.Tasks

<input class="form-control"
       value="@displayValue"
       placeholder="@Placeholder"
       inputmode="decimal"
       disabled="@Disabled"
       @oninput="OnInput"
       @onblur="OnBlur"
       @onfocus="OnFocus" />

@code {
    [Parameter]
    public decimal Value { get; set; }

    [Parameter]
    public EventCallback<decimal> ValueChanged { get; set; }

    [Parameter]
    public string? Placeholder { get; set; }

    [Parameter]
    public bool Disabled { get; set; }

    private string displayValue = string.Empty;
    private string rawValue = string.Empty;

    protected override void OnParametersSet()
    {
        // Se o usuário não está editando, mantenha a máscara no display.
        // Durante edição (focus), o displayValue é controlado por OnInput/OnFocus.
        if (string.IsNullOrWhiteSpace(rawValue))
        {
            displayValue = Format(Value);
        }
    }

    private async Task OnInput(ChangeEventArgs e)
    {
        var s = e?.Value?.ToString() ?? string.Empty;
        // Enquanto digita, não aplica máscara. Apenas guarda o texto cru.
        rawValue = s;
        displayValue = s;
    }

    private async Task OnBlur(FocusEventArgs e)
    {
        // Ao sair do campo (TAB/click), aplica a máscara e atualiza o Value.
        var parsed = ParseDecimal(rawValue);
        if (parsed.HasValue)
        {
            Value = parsed.Value;
            await ValueChanged.InvokeAsync(Value);
        }

        rawValue = string.Empty;
        displayValue = Format(Value);
        await Task.CompletedTask;
    }

    private void OnFocus(FocusEventArgs e)
    {
        // Durante edição, mostra valor "cru" e não formatado.
        rawValue = Value == 0m ? string.Empty : Value.ToString("0.##", CultureInfo.CurrentCulture);
        displayValue = rawValue;
    }

    private string Format(decimal value)
    {
        try
        {
            var ci = CultureInfo.CurrentCulture;
            return string.Format(ci, "{0:C2}", value);
        }
        catch
        {
            return value.ToString("N2");
        }
    }

    private decimal? ParseDecimal(string s)
    {
        if (string.IsNullOrWhiteSpace(s)) return 0m;

        // Aceita tanto "," quanto "." como separador decimal.
        // Estratégia: manter apenas dígitos/sinal/.,, e tratar o ÚLTIMO separador como decimal.
        var ci = CultureInfo.CurrentCulture;
        var symbol = ci.NumberFormat.CurrencySymbol;

        var cleaned = s.Replace(symbol, string.Empty)
            .Replace(" ", string.Empty)
            .Trim();

        var filtered = new string(cleaned.Where(c => char.IsDigit(c) || c == '-' || c == '.' || c == ',').ToArray());
        if (string.IsNullOrWhiteSpace(filtered)) return 0m;

        // Detecta o último separador decimal digitado.
        var lastDot = filtered.LastIndexOf('.');
        var lastComma = filtered.LastIndexOf(',');
        var decPos = Math.Max(lastDot, lastComma);

        string normalized;
        if (decPos >= 0)
        {
            var intPart = new string(filtered[..decPos].Where(char.IsDigit).ToArray());
            var fracPart = new string(filtered[(decPos + 1)..].Where(char.IsDigit).ToArray());

            // Mantém apenas 2 casas como padrão monetário (se o usuário digitar mais, corta)
            if (fracPart.Length > 2)
                fracPart = fracPart[..2];

            normalized = string.IsNullOrEmpty(fracPart)
                ? intPart
                : $"{intPart}.{fracPart}";
        }
        else
        {
            // Sem separador decimal: remove possíveis separadores de milhar
            var digits = new string(filtered.Where(c => char.IsDigit(c) || c == '-').ToArray());
            normalized = digits;
        }

        if (decimal.TryParse(normalized, NumberStyles.Number | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out var result))
            return result;

        return null;
    }
}
